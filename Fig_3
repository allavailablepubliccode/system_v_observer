%% Figure 3: Discriminating Identical Observers vs Identical Systems
% This script simulates two dynamical systems under different assumptions:
% (A) Identical observers (IO), differing in system dynamics (da ≠ 0)
% (B) Identical systems (IS), differing in observer function (dk ≠ 0)
% Each simulation uses structured input (scene driver) and noisy dynamics.
% Bayesian model reduction is applied to infer which scenario is more likely.

clear; clc; close all; rng(0);  % Reset state and random seed

%% ========== USER SETUP ==========

N       = 1000;     % Number of time points
pvr     = 1;        % Prior variance scaling (for model inversion)
U       = create_driver(N);  % Scene-based external driver

%% ========== MODEL STRUCTURE ==========

% SPM DEM integration settings
E.n     = 4;        % Embedding dimension
E.d     = 1;        % Data embedding
E.nN    = 8;        % Iterations per sample
E.s     = 1/8;      % Smoothness of fluctuations
E.dt    = 1/16;     % Integration step size
M(1).E  = E;

% Initial states: x and x tilde (two latent paths)
x.x     = 0;
x.xt    = 0;
M(1).x  = x;

% System dynamics function f
% da ≠ 0 encodes system difference between x and x~
M(1).f = @(x,v,P) [P.a         * x.x  + P.b * v;
                  (P.a + P.da) * x.xt + P.b * v];

% Observer function g
% dk ≠ 0 encodes observer difference between x and x~
M(1).g = @(x,v,P) [P.c * tanh(P.k          * x.x);
                   P.c * tanh((P.k + P.dk) * x.xt)];

% Prior mean parameters (used in simulation)
P.a  = -7/2;
P.b  = 1/64;
P.c  = 11/4;
P.k  = 9/8;

% Variances (used in simulation)
M(1).V = exp(149/16);  % Precision of observation noise
M(1).W = exp(149/16);  % Precision of state noise
M(2).v = exp(6);       % Precision of initial states
M(2).V = exp(149/16);  % Precision of input noise

%% ========== SIMULATE CASE A: Identical Observers (IO) ==========

P.da    = 2.5;  % System difference
P.dk    = 0;    % Observer identical
M(1).pE = P;

IO = spm_DEM_generate(M, U, P);

figure
subplot(2,2,1)
plot(IO.Y')
title('A: Identical Observers')
xlabel('Time')
ylabel('Output')
drawnow

%% ========== SIMULATE CASE B: Identical Systems (IS) ==========

P.da    = 0;     % System identical
P.dk    = -1.2;  % Observer difference
M(1).pE = P;

IS = spm_DEM_generate(M, U, P);

subplot(2,2,2)
plot(IS.Y')
title('B: Identical Systems')
xlabel('Time')
ylabel('Output')
drawnow

%% ========== MODEL INVERSION SETUP ==========

% Priors for inversion: assume no difference (null model)
pE = P; 
pE.da = 0;
pE.dk = 0;
M(1).pE = pE;

% Prior variances allow inference on da and dk
pC = spm_zeros(pE);
pC.da = 1;  % Allow inference on system difference
pC.dk = 1;  % Allow inference on observer difference
M(1).pC = diag(spm_vec(pC)) * pvr;

% Apply same model structure to both simulations
IO.M = M; IO.U = U;
IS.M = M; IS.U = U;

% Define reduced models for BMR
PC{1} = pC; PC{1}.dk = 0;  % Reduced model: IO
PC{2} = pC; PC{2}.da = 0;  % Reduced model: IS

%% ========== INVERT AND COMPARE IO CASE ==========

LAP_IO = spm_LAP(IO);
F_IO   = RedMod(LAP_IO, PC);

subplot(2,2,3)
bar(F_IO)
title('C: Log Evidence (IO Case)')
ylabel('F - min(F)')
xticklabels({'IO','IS'})
drawnow

%% ========== INVERT AND COMPARE IS CASE ==========

LAP_IS = spm_LAP(IS);
F_IS   = RedMod(LAP_IS, PC);

subplot(2,2,4)
bar(F_IS)
title('D: Log Evidence (IS Case)')
ylabel('F - min(F)')
xticklabels({'IO','IS'})
drawnow

%% ========== SOFTMAX PROBABILITIES (Optional Insets) ==========

figure
subplot(2,2,1)
bar(spm_softmax(F_IO(:)))
title('C Inset: Posterior (IO)')
xticklabels({'IO','IS'})
ylim([0 1])

subplot(2,2,2)
bar(spm_softmax(F_IS(:)))
title('D Inset: Posterior (IS)')
xticklabels({'IO','IS'})
ylim([0 1])

%% ========== Function for Model Reduction ==========

function F = RedMod(LAP, PC)
% Computes log evidence for reduced models using spm_log_evidence
qE = LAP.qP.P{1};
qC = LAP.qP.C;
pE = LAP.M(1).pE;
pC = LAP.M(1).pC;
for m = 1:numel(PC)
    rC = diag(spm_vec(PC{m}));
    F(m,1) = spm_log_evidence(qE,qC,pE,pC,pE,rC);
end
F = F - min(F);  % Normalize for comparison
end

function driver = create_driver(N)
% CREATE_DRIVER generates a structured input regressor with noise.
%
% This function simulates an input timeseries composed of two components:
% (1) Low-frequency, block-like structure based on scene transitions (e.g. movie cutpoints).
% (2) Superimposed high-frequency Gaussian noise.
% This is used as input for system–observer generative model simulations.
%
% INPUT:
%   N        - Total number of timepoints to generate
%
% OUTPUT:
%   driver   - 1 x N input vector combining structure + noise
%
% NOTE:
%   You must have a file called `scenecut_info.csv` containing cut times
%   in seconds, located at:
%   ~/Dropbox/Work/System_Observer/data/lfp_ieeg/scenecut_info.csv
%
%   If needed, adjust the file path and target sampling rate below.

    % ---------------------- Settings ----------------------
    targ_fs    = 250;   % Target sampling rate (Hz)
    scene_file = 'your_path';

    % ---------------------- Load scene transitions ----------------------
    % These define block-wise changes in the driver (e.g. movie scenes)
    scene_cuts = readmatrix(scene_file);  % In seconds

    % Convert to sample indices
    scene_samples = round(scene_cuts * targ_fs);
    scene_samples = scene_samples(scene_samples > 1 & scene_samples < N);

    % Define scene segment start/end points
    scene_boundaries = unique([1, scene_samples(:)', N + 1]);
    n_scenes = numel(scene_boundaries) - 1;

    % ---------------------- Base signal ----------------------
    % Random constant value per scene block (low frequency structure)
    rng(0);  % Reproducibility
    base = zeros(1, N);
    scene_values = rand(1, n_scenes) * 2 - 1;  % Uniform in [-1, 1]

    for s = 1:n_scenes
        idx_start = scene_boundaries(s);
        idx_end   = scene_boundaries(s + 1) - 1;
        base(idx_start:idx_end) = scene_values(s);
    end

    % ---------------------- Add noise ----------------------
    noise  = 0.5 * randn(1, N);              % Fast fluctuations
    driver = base + noise;                   % Combined input
    driver = smoothdata(driver, 'gaussian', 5);  % Optional smoothing
end
